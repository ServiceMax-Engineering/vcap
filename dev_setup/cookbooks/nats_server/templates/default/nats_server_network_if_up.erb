#! /bin/sh
# Reload the nats_server when an interface comes up, to allow it to start
# listening on new addresses.
# This is only enabled if the config file of the nats_server has a tracked-net-iface line
# That defines what interface its IP must be.

set -e

# Don't bother to restart nats-server when lo is configured.
if [ "$IFACE" = lo ]; then
        exit 0
fi

# Only run from ifup.
#if [ "$MODE" != start ]; then
#        exit 0
#fi

# nats_server only cares about inet and inet6. Get ye gone, strange people
# still using ipx.
#if [ "$ADDRFAM" != inet ] && [ "$ADDRFAM" != inet6 ]; then
#        exit 0
#fi

# Is the exec ready?
if [ ! -e /etc/init.d/nats_server ]; then
        exit 0
fi

# Update the host on which the nats-server is running.
# At the moment we only look after one particular interface which
# is defined in the config file of nats-server.
# Read the path of the config file: it look like this:
# DAEMON_ARGS="-d -c /home/ubuntu/cloudfoundry/.deployments/intalio_micro_cf/config/nats_server/nats_server.yml"
NATS_CONF=`grep DAEMON_ARGS=  /etc/init.d/nats_server | egrep -o ' -c [^\"]*' | cut -d' ' -f3`
if [ ! -e "$NATS_CONF" ]; then
  # Attempt to read the path of the config file directly from the /etc/init.d/nats_server: it look like this:
  # DAEMON_ARGS="-d -c /home/ubuntu/cloudfoundry/.deployments/intalio_micro_cf/config/nats_server/nats_server.yml"
  NATS_CONF=`grep DAEMON_ARGS=  /etc/init.d/nats_server | egrep -o ' -c [^\"]*' | cut -d' ' -f3`
fi
if [ ! -e "$NATS_CONF" ]; then
        exit 0
fi
# Now in that file look for the tracked interface:
# tracked-net-iface: eth0
NATS_TRACKED_IFACE=`grep tracked_net_iface: $NATS_CONF | cut -d' ' -f2`
if [ "$IFACE" != "$NATS_TRACKED_IFACE" ]; then
        exit 0
fi

# Read the IP for this IFACE and then make sure that nats_server config file has that IP
IP=`ifconfig | sed -n '/'$IFACE'/{n;p;}' | grep 'inet addr:' | grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}' | head -1`
if [ -z "$IP" ]; then
#Unexpected to say the least but we don't want to replace a good IP by a blank string.
        exit 0;
fi

LOG_FILE=/var/log/nats_server_if_up.log
touch $LOG_FILE
chmod o+rw $LOG_FILE # so that the postgres user can write into it.
date=$( date +"%Y-%m-%d_%H:%M:%S" )

# Make sure the hostname is unique on the subnet.
# Computes the ipseed the last couple of digits from the ip depending on the subnet mask
# For a given prefix, prefix-seed is guaranteed to be unique on the corresponding subnet.
etc_hostname=`cat /etc/hostname | head -1`
hostname_now=`hostname`
for hname in "ubuntu" "vcap" "cloudfoundry" "intalio"; do
  if [ $etc_hostname = "$hname" -a "$hostname_now" = "$hname" ]; then
    mask=`ifconfig "$IFACE" | sed -rn '2s/ .*:(.*)$/\1/p'`
    case $mask in
      255.255.255.*) seed=`echo $ip | cut -d. -f4` ;;
      255.255.*) seed=`echo $ip | cut -d. -f3,4 | tr . -` ;;
      255.*) seed=`echo $ip | cut -d. -f2,3,4 | tr . -` ;;
      *) seed=`echo $ip | cut -d. -f1,2,3,4 | tr . -` ;;
    esac
    hostname_new="$etc_hostname-$seed"
    hostname "$hostname_new"
    #also update /etc/hosts unfortunately keep the old one and put the new one too
    sed -i 's/^127\.0\.1\.1[[:space:]]*.*$/127.0.1.1    '$hname' '$hostname_new'/g' /etc/hosts
    avahi-daemon --check
    [ "$?" = "0" ] && avahi-daemon --kill #reload is not enough; avahi-daemon will be respawned
  fi
done
# end of hostname unique on the subnet

#Currently written IP: net: 192.168.1.8
NATS_IP=`grep net: $NATS_CONF | cut -d' ' -f2`
if [ "$NATS_IP" = "$IP" ]; then
#no change.
# now that the IP is ready; it is a good time to start vcap:
  message="$date The tracked network interface's IP is available as IP=$IP."
  echo "$message" >> $LOG_FILE
  set +e
  echo "  (Re)Starting nats_server and waiting 5 seconds." >> $LOG_FILE
  /etc/init.d/nats_server stop || true >> $LOG_FILE
  /etc/init.d/nats_server start || true >> $LOG_FILE
  sleep 5
  echo "  (Re)Starting vcap." >> $LOG_FILE
  sudo -i -u <%= node[:deployment][:user] %> <%= node[:deployment][:vcap_exec] %> restart
  exit 0
fi

# It changed. Let's update them all:
#sed -i "s/#{@old_local_ip}/#{@local_ip}/g
#/home/ubuntu/cloudfoundry/_vcap update-ip $NATS_TRACKED_IFACE
echo "$date The tracked network interface's IP has changed from $NATS_IP to $IP. Updating all the config of the nats_server and the vcap components." >> $LOG_FILE

#migrate the credentials that also contain the old IP.
#todo: add a few more parameters and put this into a separate file related to the cloud_controller
# make sure that postgresql is actually started

PSQL_RAW_RES_ARGS="-P format=unaligned -P footer=off -P tuples_only=on"
postgres_pid=`[ -d /var/run/postgresql -a -n "$(ls /var/run/postgresql/)" ] && ls /var/run/postgresql/*.pid || echo ""`
if [ -z "$postgres_pid" ]; then
  echo "Starting Postgresql" >> $LOG_FILE
  /etc/init.d/postgresql start
  COUNTER=0
  while [  $COUNTER -lt 20 ]; do
    sudo -u postgres psql -e -c "select 1" 2>&1 | tee -a $LOG_FILE
    psql_exit_status=$?
    res=`sudo -u postgres psql -c "select 1" $PSQL_RAW_RES_ARGS`
    if [ "$psql_exit_status" == 0 -a "$res" == "1" ]; then
      COUNTER=40
      [ COUNTER != "0" ] && echo "Postgresql is available" >> $LOG_FILE
    else
      echo "[ $COUNTER ] Postgresql is not available yet." >> $LOG_FILE
      let COUNTER=COUNTER+1
      sleep 5
    fi
  done
else
  echo "Postgresql was started $postgres_pid" >> $LOG_FILE
fi
sudo -u postgres psql -d cloud_controller -e -c "update service_configs set credentials = replace(credentials, '$NATS_IP', '$IP')" 2>&1 | tee -a $LOG_FILE
echo "Exit status from the psql command $?" >> $LOG_FILE
sudo -u postgres psql -d cloud_controller -e -c "update service_bindings set credentials = replace(credentials, '$NATS_IP', '$IP')" 2>&1 | tee -a $LOG_FILE
psql_exit_status=$?
if [ "$psql_exit_status" != 0 ]; then
  echo "Exit status from the psql command $psql_exit_status; We exit and don't change the IP in the config file; try again!" >> $LOG_FILE
  exit 12
else
  # double check.
  sudo -u postgres psql -d cloud_controller -e -c "select count(*) from service_bindings where credentials like '%$NATS_IP%'" 2>&1 | tee -a $LOG_FILE
  rows_with_old_ip=`sudo -u postgres psql -d cloud_controller -c "select count(*) from service_bindings where credentials like '%$NATS_IP%'" $PSQL_RAW_RES_ARGS`
  echo "Number of rows with old ip $NATS_IP: $rows_with_old_ip" >> $LOG_FILE
  if [ "$rows_with_old_ip" != 0 ]; then
    echo "The refactoring in the DB did not happen $rows_with_old_ip; failure!" >> $LOG_FILE
    echo 11
  fi
#echo "Just testing: exit for now" >> $LOG_FILE
#exit 0
fi
find <%= node[:deployment][:config_path] %>/ -type f -exec sed -i 's/'$NATS_IP'/'$IP'/g' {} \;

# Maybe monit that commonly monitors nats_server is already started.
# In that case let's restart monit
if [ ! -f /var/run/monit.pid ] || \
   [ "$(ps -p "$(cat /var/run/monit.pid)" -o comm=)" != 'monit' ]; then
        echo "    The monit daemon was not running." >> $LOG_FILE
   sudo -i -u <%= node[:deployment][:user] %> <%= node[:deployment][:vcap_exec] %> stop
else
   echo "    Monit was running. Restarting the vcap-daemons and vcap processes from it." >> $LOG_FILE
   set +e
   monit -g vcap stop
   monit -g vcap_daemons stop
   /etc/init.d/nats_server stop || true
   /etc/init.d/nats_server start || true
   sudo -i -u <%= node[:deployment][:user] %> <%= node[:deployment][:vcap_exec] %> restart
   sleep 10
   monit -g vcap start
   exit 0
fi

# Maybe monit that commonly monitors nats_server is already started.
# In that case let's restart monit
if [ ! -f /var/run/monit.pid ] || \
   [ "$(ps -p "$(cat /var/run/monit.pid)" -o comm=)" != 'monit' ]; then
        echo "    The monit daemon was not running." >> $LOG_FILE
else
   echo "    Monit was running. Restarting the vcap-daemons and vcap processes from it." >> $LOG_FILE
   set e+
   monit -g vcap stop
   #/etc/init.d/nats_server stop || true
   monit -g vcap_daemons restart
   sleep 10
   monit -g vcap start
   exit 0
fi

# Make sure that the nats-server is started before we restart it.
if [ ! -f /var/run/nats_server.pid ] || \
   [ "$(ps -p "$(cat /var/run/nats_server.pid)" -o comm=)" != 'nats-server' ]; then
        echo "    The nats_server was not running." >> $LOG_FILE
        exit 0
fi
echo "    The nats_server was running. Restarting it." >> $LOG_FILE

# Let's use a force-reload.
/etc/init.d/nats_server stop || true
/etc/init.d/nats_server start || true

# We should also reload the vcap components at this point if they are started
sleep 3
sudo -i -u <%= node[:deployment][:user] %> <%= node[:deployment][:vcap_exec] %> restart

exit 0


